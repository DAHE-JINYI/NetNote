# 4. WebSockets

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket)

此部分参考文档涵盖对 Servlet 堆栈的支持，包括原始 WebSocket 交互的 WebSocket 消息传递，通过 SockJS 进行 WebSocket 仿真以及通过 STOMP 作为 WebSocket 的子协议进行发布、订阅消息传递。

## 4.1. WebSocket 概论

WebSocket 协议 [RFC 6455](https://tools.ietf.org/html/rfc6455) 提供了一种标准化方法，可通过单个 TCP 连接在客户端与服务端之间建立全双工双向通信通道。
它是与 HTTP 不同的 TCP 协议，但旨在通过端口 80 与 443 在 HTTP 上工作，并允许重复使用现有的防火墙规则。

WebSocket 交互始于一个 HTTP 请求，该请求使用 HTTP `Upgrade` 标头进行升级，或者在这种情况下切换到 WebSocket 协议。
以下示例展示了这种交互：

```YAML {3,4}
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080
```

1. `Upgrade` 标头。
2. 使用 `Upgrade` 连接。

具有 WebSocket 支持的服务端代替通常的 200 状态代码，返回类似于以下内容的输出：

```YAML {1}
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```

1. 协议切换

握手成功后，HTTP 升级请求的基础 TCP 套接字将保持打开状态，客户端与服务端均可继续发送与接收消息。

WebSockets 的工作原理的完整介绍超出了本文档的范围。
请参阅 RFC 6455，HTML5 的 WebSocket 章节，或 Web 上的许多简介和教程中的任何一个。

请注意，如果 WebSocket 服务端在 Web 服务器（例如 nginx）后面运行，那么可能需要对其进行配置，以将 WebSocket 升级请求传递到 WebSocket 服务端。
同样，如果应用程序在云环境中运行，请检查与 WebSocket 支持相关的云提供商的说明。

### 4.1.1. HTTP 对比 WebSocket

尽管 WebSocket 被设计为与 HTTP 兼容并以 HTTP 请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构与应用程序编程模型。

在 HTTP 与 REST 中，应用程序被建模为许多 URL。
为了与应用程序交互，客户端访问那些 URL，即请求 - 响应风格。
服务端根据 HTTP URL、方法与标头将请求路由到适当的处理程序。

相比之下，在 WebSockets 中，初始连接通常只有一个 URL。
随后，所有应用程序消息都在同一 TCP 连接上流动。
这指向了一个完全不同的异步、事件驱动的消息传递体系结构。

WebSocket 也是一种低级传输协议，与 HTTP 不同，它不对消息的内容规定任何语义。
这意味着除非客户端与服务端就消息语义达成一致，否则就无法路由或处理消息。

WebSocket 客户端与服务端可以通过 HTTP 握手请求上的 `Sec-WebSocket-Protocol` 标头协商使用更高级别的消息协议（例如 STOMP）。
在这种情况下，它们需要提出自己的约定。

### 4.1.2. 何时使用 WebSockets

WebSockets 可以使网页具有动态性与交互性。
但是，在许多情况下，结合使用 Ajax 与 HTTP 流或长时间轮询可以提供一种简单有效的解决方案。

例如，新闻、邮件与社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。
另一方面，协作、游戏与金融应用程序需要更接近实时。

仅延迟并不是决定因素。
如果消息量相对较少（例如，监视网络故障），那么 HTTP 流或轮询可以提供有效的解决方案。
低延迟，高频率与高音量的结合才是使用 WebSocket 的最佳案例。

还请记住，在 Internet 上，不受控制的代理可能会阻止 WebSocket 交互，这可能是因为未将它们配置为传递 `Upgrade` 标头，或者是因为它们关闭了长期处于空闲状态的连接。
这意味着与面向公众的应用程序相比，将 WebSocket 用于防火墙内部的应用程序是一个更直接的决定。

## 4.2. WebSocket API

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handler)

Spring 框架提供了一个 WebSocket API，可用于编写处理 WebSocket 消息的客户端与服务端应用程序。

### 4.2.1. `WebSocketHandler`

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handler)

创建 WebSocket 服务端就像实现 `WebSocketHandler` 一样简单，或者更可能地，扩展 `TextWebSocketHandler` 或 `BinaryWebSocketHandler`。
下面的示例使用 `TextWebSocketHandler`：

```Java
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.TextMessage;

public class MyHandler extends TextWebSocketHandler {

    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) {
        // ...
    }

}
```

有专用的 WebSocket Java 配置与 XML 命名空间支持，用于将前面的 WebSocket 处理程序映射到特定的 URL，如以下示例所示：

```Java
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

前面的示例用于 Spring MVC 应用程序，应该包含在 [`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) 的配置中。
但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。
在 [`WebSocketHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html) 的帮助下将 `WebSocketHandler` 集成到其他 HTTP 服务环境中相对简单。

### 4.2.2. WebSocket 握手

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handshake)

定制初始 HTTP WebSocket 握手请求的最简单方法是通过 `HandshakeInterceptor`，它公开了“握手之前”与“握手之后”的方法。
可以使用此类拦截器来阻止握手或使任何属性对 `WebSocketSession` 可用。
以下示例使用内置的拦截器将 HTTP 会话属性传递到 WebSocket 会话：

```Java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyHandler(), "/myHandler")
            .addInterceptors(new HttpSessionHandshakeInterceptor());
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:handshake-interceptors>
            <bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
        </websocket:handshake-interceptors>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

一个更高级的选项是扩展 `DefaultHandshakeHandler`，它执行 WebSocket 握手的步骤，包括验证客户端来源、协商子协议以及其他详细信息。
如果应用程序需要配置自定义 `RequestUpgradeStrategy` 以便适应尚不支持的 WebSocket 服务端引擎与版本，那么可能还需要使用此选项
（有关此主题的更多信息，请参阅 [部署](#_4-2-3-部署)）。
Java 配置与 XML 命名空间都使配置自定义 `HandshakeHandler` 成为可能。

::: warning
Spring 提供了一个 `WebSocketHandlerDecorator` 基类，可用于装饰 `WebSocketHandler` 并具有其他行为。
使用 WebSocket Java 配置或 XML 命名空间时，默认情况下会提供并添加日志记录与异常处理实现。
`ExceptionWebSocketHandlerDecorator` 捕获由任何 `WebSocketHandler` 方法引起的所有未捕获的异常，并关闭状态为 `1011`（指示服务端错误）的 WebSocket 会话。
:::

### 4.2.3. 部署

Spring WebSocket API 易于集成到 Spring MVC 应用程序中，在该应用程序中，`DispatcherServlet` 同时提供 HTTP WebSocket 握手与其他 HTTP 请求。
通过调用 `WebSocketHttpRequestHandler`，也很容易集成到其他 HTTP 处理方案中。
这是方便且易于理解的。
但是，对于 JSR-356 运行时，需要特别注意。

Java WebSocket API（JSR-356）提供了两种部署机制。
首先涉及启动时的 Servlet 容器类路径扫描（Servlet 3 特性）。
另一个是在 Servlet 容器初始化时使用的注册 API。
这两种机制均无法使用单个“前端控制器”进行所有 HTTP 处理（包括 WebSocket 握手与所有其他 HTTP 请求，例如：Spring MVC 的 `DispatcherServlet`）。

这是 JSR-356 的一个重大限制，即使在 JSR-356 运行时中运行，Spring 的 WebSocket 支持也可以通过服务端特定的 `RequestUpgradeStrategy` 实现解决。
Tomcat、Jetty、GlassFish、WebLogic、WebSphere 与 Undertow（与 WildFly）目前存在此类策略。

::: tip
已经创建了克服 Java WebSocket API 中的上述限制的请求，可以在 [eclipse-ee4j/websocket-api#211](https://github.com/eclipse-ee4j/websocket-api/issues/211) 中进行跟踪。
Tomcat、Undertow 与 WebSphere 提供了自己的 API 替代方案，使之可以做到这一点，而 Jetty 也可以实现。
我们希望更多的服务端可以做到这一点。
:::

第二个考虑因素是，希望支持 JSR-356 的 Servlet 容器执行 `ServletContainerInitializer`（SCI）扫描，这可能会减慢应用程序的启动速度，在某些情况下会大大降低速度。
如果在升级到具有 JSR-356 支持的 Servlet 容器版本后观察到重大影响，那么应该可以通过使用 `web.xml` 中的 `<absolute-ordering />` 元素有选择地启用或禁用 Web 片段（和 SCI 扫描）,如以下示例所示：

```XML
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering/>

</web-app>
```

然后，可以按名称选择性地启用 Web 片段，例如 Spring 自己的 `SpringServletContainerInitializer`，它提供对 Servlet 3 Java 初始化 API 的支持。
以下示例展示了如何执行此操作：

```XML
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering>
        <name>spring_web</name>
    </absolute-ordering>

</web-app>
```

### 4.2.4. 服务端配置

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-config)

每个基础的 WebSocket 引擎都公开配置属性，这些属性控制运行时特征，例如消息缓冲区大小的大小、空闲超时等。

对于 Tomcat、WildFly 与 GlassFish，可以将 `ServletServerContainerFactoryBean` 添加到 WebSocket Java 配置中，如以下示例所示：

```Java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        container.setMaxTextMessageBufferSize(8192);
        container.setMaxBinaryMessageBufferSize(8192);
        return container;
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <bean class="org.springframework...ServletServerContainerFactoryBean">
        <property name="maxTextMessageBufferSize" value="8192"/>
        <property name="maxBinaryMessageBufferSize" value="8192"/>
    </bean>

</beans>
```

::: tip
对于客户端 WebSocket 配置，应使用 `WebSocketContainerFactoryBean`（XML）或 `ContainerProvider.getWebSocketContainer()`（Java 配置）。
:::

对于 Jetty，需要提供一个预先配置的 Jetty `WebSocketServerFactory`，然后通过 WebSocket Java 配置将其注入 Spring 的 `DefaultHandshakeHandler` 中。
以下示例展示了如何执行此操作：

```Java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoWebSocketHandler(),
            "/echo").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/echo" handler="echoHandler"/>
        <websocket:handshake-handler ref="handshakeHandler"/>
    </websocket:handlers>

    <bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
        <constructor-arg ref="upgradeStrategy"/>
    </bean>

    <bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
        <constructor-arg ref="serverFactory"/>
    </bean>

    <bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
        <constructor-arg>
            <bean class="org.eclipse.jetty...WebSocketPolicy">
                <constructor-arg value="SERVER"/>
                <property name="inputBufferSize" value="8092"/>
                <property name="idleTimeout" value="600000"/>
            </bean>
        </constructor-arg>
    </bean>

</beans>
```

### 4.2.5. 允许的来源

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-cors)

从 Spring Framework 4.1.5 开始，WebSocket 与 SockJS 的默认行为是仅接受同源请求。
也可以允许所有或指定的来源列表。
此检查主要用于浏览器客户端。
没有任何措施可以阻止其他类型的客户端修改 `Origin` 标头值（有关更多详细信息，请参阅 [RFC 6454: Web 源概念](https://tools.ietf.org/html/rfc6454)）。

三种可能的行为是：

* 仅允许相同来源的请求（默认）：
  在此模式下，启用 SockJS 后，Iframe HTTP 响应标头 `X-Frame-Options` 设置为 `SAMEORIGIN`，并且 JSONP 传输被禁用，因为它不允许检查请求的来源。
  因此，启用此模式时，不支持 IE6 与 IE7。

* 允许指定来源列表：
  每个允许的来源必须以 `http://` 或 `https://` 开头。
  在此模式下，启用 SockJS 后，将禁用 IFrame 传输。
  因此，启用此模式时，不支持 IE6 到 IE9。

* 允许所有来源：
  要启用此模式，应提供 `*` 作为允许的来源值。
  在这种模式下，所有传输都可用。

可以配置 WebSocket 与 SockJS 允许的来源，如以下示例所示：

```Java
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers allowed-origins="https://mydomain.com">
        <websocket:mapping path="/myHandler" handler="myHandler" />
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

## 4.3. SockJS 回退

在公共互联网上，控件外部的限制性代理可能会阻止 WebSocket 交互，这可能是因为未将它们配置为传递 `Upgrade` 标头，或者是因为它们关闭了长期处于空闲状态的连接。

解决此问题的方法是 WebSocket 模拟，即先尝试使用 WebSocket，然后再尝试使用基于 HTTP 的技术来模拟 WebSocket 交互并公开相同的应用程序级 API。

在 Servlet 技术栈上，Spring 框架为 SockJS 协议提供服务端与客户端支持。

### 4.3.1. 概览

SockJS 的目标是让应用程序使用 WebSocket API，但在运行时的必要时刻回退到非 WebSocket 替代方案，而无需更改应用程序代码。

SockJS 包含：

* [SockJS 协议](https://github.com/sockjs/sockjs-protocol)以可执行 [叙述性测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html) 的形式定义。

* [SockJS JavaScript 客户端](https://github.com/sockjs/sockjs-client/)——一种在浏览器中使用的客户端库。

* SockJS 服务端实现，包含一个 Spring 框架的 `spring-websocket` 模块。

* `spring-websocket` 模块中的 SockJS Java 客户端（从 4.1 版开始）。

SockJS 设计用于浏览器。
它使用多种技术来支持各种浏览器版本。
有关 SockJS 传输类型与浏览器的完整列表，请参见 [SockJS 客户端](https://github.com/sockjs/sockjs-client/)页面。
传输分为三大类：WebSocket、HTTP 流与 HTTP 长轮询。
有关这些类别的概述，请参阅[此博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

SockJS 客户端首先发送 `GET/info` 以从服务端获取基本信息。
在那之后，它必须决定使用哪种传输方式。
如果可能，将使用 WebSocket。
如果没有，在大多数浏览器中，至少有一个 HTTP 流选项。
如果不是，则使用 HTTP（长）轮询。

所有传输请求都具有以下 URL 结构：

```text
https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
```

此处：

* `{server-id}` 用于在集群中路由请求，但在其他情况下不使用。

* `{session-id}` 用于关联属于 SockJS 会话的 HTTP 请求。

* `{transport}` 用于指示传输类型（例如：websocket、xhr-streaming、等）。

WebSocket 传输仅需要单个 HTTP 请求即可进行 WebSocket 握手。
此后所有消息在该套接字上交换。

HTTP 传输需要更多请求。
例如，Ajax/XHR 流依赖于对服务端到客户端消息的一个长时间运行的请求，以及对客户端到服务端消息的其他 HTTP POST 请求。
长轮询与此类似，不同之处在于长轮询在每次服务端到客户端发送后结束当前请求。

SockJS 增加了最小消息帧。
例如，服务端最初发送字母 `o`（“开启”帧），消息以 `a["message1","message2"]`（JSON 编码数组）发送，如果 25 秒内（默认）没有消息，那么发送字母 `h`（“心跳”帧），最后使用字母 `c`（“关闭”帧）关闭会话。

要了解更多信息，请在浏览器中运行示例并查看 HTTP 请求。
SockJS 客户端允许修复传输列表，因此可以一次查看每个传输。
SockJS 客户端还提供了调试标志，该标志可在浏览器控制台中支持有用的消息。
在服务端，可以为 `org.springframework.web.socket` 启用 `TRACE` 日志记录。
有关更多详细信息，请参见 SockJS 协议[叙述测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html)。

### 4.3.2. 使能 SockJS

可以通过 Java 配置启用 SockJS，如以下示例所示：

```Java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").withSockJS();
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:sockjs/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

前面的示例用于 Spring MVC 应用程序，应该包含在 [`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) 的配置中。
但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。
在 [`WebSocketHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html) 的帮助下将 `WebSocketHandler` 集成到其他 HTTP 服务环境中相对简单。

在浏览器端，应用程序可以使用 [`sockjs-client`](https://github.com/sockjs/sockjs-client/)（版本 1.0.x）。
它模拟 W3C WebSocket API，并与服务端通信以选择最佳的传输选项，具体取决于运行它的浏览器。
请参阅 [sockjs-client](https://github.com/sockjs/sockjs-client/) 页面与浏览器支持的传输类型列表。
客户端还提供了几个配置选项，例如用于指定要包含的传输。

### 4.3.3. IE 8 与 9

Internet Explorer 8 与 9 仍在使用。
它们是拥有 SockJS 的关键原因。
本节涵盖有关在这些浏览器中运行的重要注意事项。

SockJS 客户端通过使用 Microsoft 的 [`XDomainRequest`](https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx) 在 IE 8 与 9 中支持 Ajax/XHR 流。
跨域有效，但不支持发送 Cookie。
Cookies 对于 Java 应用程序通常是必不可少的。
但是，由于 SockJS 客户端可用于多种服务端类型（而不仅仅是 Java 类型），因此它需要知道 cookie 是否重要。
如果是这样，那么 SockJS 客户端更倾向 Ajax/XHR 进行流传输。
否则，它依赖于基于 iframe 的技术。

SockJS 客户端的第一个 `/info` 请求是对详细信息的请求，这些信息可以影响客户端对传输方式的选择。
这些详细信息之一是服务端应用程序是否依赖 Cookie（例如，出于身份验证目的或使用粘性会话进行群集）。
Spring 对 SockJS 的支持包括一个名为 `sessionCookieNeeded` 的属性。
由于大多数 Java 应用程序都依赖 `JSESSIONID` cookie，因此默认情况下启用该功能。
如果应用程序不需要它，那么可以关闭此选项，然后 SockJS 客户端应在 IE 8 与 9 中选择 `xdr-streaming`。

如果确实使用基于 iframe 的传输，请记住，可以通过将 HTTP 响应标头 `X-Frame-Options` 设置为 `DENY`、`SAMEORIGIN` 或 `ALLOW-FROM <origin>` 来指示浏览器阻止在给定页面上使用 iframe。
这用于防止[点击劫持](https://www.owasp.org/index.php/Clickjacking)。

::: tip
Spring Security 3.2+ 提供了对每个响应设置 `X-Frame-Options` 的支持。
默认情况下，Spring Security Java 配置将其设置为 `DENY`。
在 3.2 中，Spring Security XML 命名空间默认情况下不设置该标头，但可以配置为这样做。
将来，它可能会成为默认设置。

有关如何配置 `X-Frame-Options` 标头设置的详细信息，请参见 Spring Security 文档的[默认安全标头](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers)。
也可以查看 [SEC-2501](https://jira.spring.io/browse/SEC-2501) 以获取更多背景信息。
:::

如果应用程序添加了 `X-Frame-Options` 响应标头（应该如此！）并依赖于基于 iframe 的传输，那么需要将标头值设置为 `SAMEORIGIN` 或 `ALLOW-FROM <origin>`。
Spring SockJS 支持还需要知道 SockJS 客户端的位置，因为它是从 iframe 加载的。
默认情况下，iframe 设置为从 CDN 位置下载 SockJS 客户端。
最好将此选项配置为使用与应用程序源相同的 URL。

以下示例展示了如何在 Java 配置中执行此操作：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS()
                .setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
    }

    // ...

}
```

XML 命名空间通过 `<websocket:sockjs>` 元素提供了类似的选项。

::: tip
在初始开发过程中，请启用 SockJS 客户端开发模式，以防止浏览器缓存本应缓存的 SockJS 请求（如 iframe）。
有关如何启用它的详细信息，请参见 [SockJS 客户端](https://github.com/sockjs/sockjs-client/) 页面。
:::

### 4.3.4. 心跳

SockJS 协议要求服务端发送心跳消息，以防止代理断定连接挂起。
Spring SockJS 配置具有一个名为 `heartbeatTime` 的属性，可用于自定义频率。
默认情况下，假设没有其他消息在该连接上发送，那么心跳将在 25 秒后发送。
这个 25 秒的值符合以下对公共互联网应用程序的 [IETF 建议](https://tools.ietf.org/html/rfc6202)。

::: tip
在 WebSocket 与 SockJS 上使用 STOMP 时，如果 STOMP 客户端与服务端协商要交换的心跳，将会禁用 SockJS 心跳。
:::

Spring SockJS 支持还允许配置 `TaskScheduler` 来计划心跳任务。
任务调度程序由线程池支持，其默认设置基于可用处理器的数量。
应该考虑根据特定需求自定义设置。

### 4.3.5. 客户端挂断

HTTP 流与 HTTP 长轮询 SockJS 传输要求连接保持打开的时间比平常更长。
有关这些技术的概述，请参见[此博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，该支持允许退出 Servlet 容器线程，处理请求并继续写入另一个线程的响应。

一个特定的问题是，Servlet API 不会为已离开的客户端提供通知。
请参阅 [eclipse-ee4j/servlet-api#44](https://github.com/eclipse-ee4j/servlet-api/issues/44)。
但是，Servlet 容器在随后尝试写入响应时会引发异常。
由于 Spring 的 SockJS 服务支持服务端发送的心跳信号（默认情况下，每 25 秒发送一次），这意味着通常会在该时间段内（如果消息发送频率更高将更早）检测到客户端断开连接。

::: tip
结果，由于客户端已断开连接，可能会发生网络 I/O 故障，这可能会在日志中填充不必要的堆栈跟踪。
Spring 会尽最大努力找出代表客户端断开连接（特定于每个服务器）的网络故障，并通过使用专用日志类别 `DISCONNECTED_CLIENT_LOG_CATEGORY`（在 `AbstractSockJsSession` 中定义）来记录一条最小的消息。
如果需要查看堆栈跟踪，可以将该日志类别设置为 `TRACE`。
:::

### 4.3.6. SockJS 与 CORS

如果允许跨域请求（请参阅“[允许的来源](#_4-2-5-允许的来源)”），那么 SockJS 协议使用 CORS 在 XHR 流与轮询传输中提供跨域支持。
因此，除非在响应中检测到 CORS 标头的存在，否则将自动添加 CORS 标头。
因此，如果已经将应用程序配置为提供 CORS 支持（例如，通过 Servlet 过滤器），那么 Spring 的 `SockJsService` 会跳过这一部分。

也可以通过在 Spring 的 SockJsService 中设置 `suppressCors` 属性来禁止添加这些 CORS 标头。

SockJS 需要以下标头与值：

* `Access-Control-Allow-Origin`：从 `Origin` 请求标头的值初始化。

* `Access-Control-Allow-Credentials`：始终设置为 `true`。

* `Access-Control-Request-Headers`：从等效请求标头中的值初始化。

* `Access-Control-Allow-Methods`：传输支持的 HTTP 方法（请参见 `TransportType` 枚举）。

* `Access-Control-Max-Age`：设置为 31536000（1 年）。

有关确切的实现，请参见 `AbstractSockJsService` 中的 `addCorsHeaders` 与源代码中的 `TransportType` 枚举。

另外，如果 CORS 配置允许，请考虑排除带有 SockJS 端点前缀的 URL，从而让 Spring 的 `SockJsService` 处理它。

### 4.3.7. `SockJsClient`

Spring 提供了一个 SockJS Java 客户端，无需使用浏览器即可连接到远程 SockJS 端点。
当需要通过公共网络在两个服务器之间进行双向通信时（这是网络代理可以阻止使用 WebSocket 协议的地方），这特别有用。
SockJS Java 客户端对于测试目的（例如，模拟大量并发用户）也非常有用。

SockJS Java 客户端支持 `websocket`、`xhr-streaming` 与 `xhr-polling` 传输。
其余的仅在浏览器中有意义。

可以使用以下命令配置 `WebSocketTransport`：

* JSR-356 运行时的 `StandardWebSocketClient`

* 通过使用 Jetty 9+ 本机 WebSocket API 来创建 `JettyWebSocketClient`。

* Spring 的 `WebSocketClient` 的任何实现。

根据定义，`XhrTransport` 支持 `xhr-streaming` 与 `xhr-polling`，因为从客户端的角度来看，除了用于连接服务器的 URL 之外没有其他区别。
当前有两种实现：

* `RestTemplateXhrTransport` 使用 Spring 的 `RestTemplate` 进行 HTTP 请求。

* `JettyXhrTransport` 使用 Jetty 的 `HttpClient` 进行 HTTP 请求。

以下示例展示了如何创建 SockJS 客户端并连接到 SockJS 端点：

```Java
List<Transport> transports = new ArrayList<>(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

SockJsClient sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
```

::: tip
SockJS 对消息使用 JSON 格式的数组。
默认情况下，使用 Jackson 2，并且需要在类路径上。
或者，可以配置 `SockJsMessageCodec` 的自定义实现，并在 `SockJsClient` 上对其进行配置。
:::

要使用 `SockJsClient` 模拟大量并发用户，需要配置基础 HTTP 客户端（用于 XHR 传输）以允许足够数量的连接与线程。
以下示例展示了如何使用 Jetty 进行操作：

```Java
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
```

下面的示例展示了与服务端 SockJS 相关的属性（有关详细信息，请参见 javadoc），还应该考虑自定义：

```Java {7,8,9}
@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/sockjs").withSockJS()
            .setStreamBytesLimit(512 * 1024) 
            .setHttpMessageCacheSize(1000) 
            .setDisconnectDelay(30 * 1000); 
    }

    // ...
}
```

1. 将 `streamBytesLimit` 属性设置为 512KB（默认值为 128KB——`128 * 1024`）。

2. 将 `httpMessageCacheSize` 属性设置为 1,000（默认值为 `100`）。

3. 将断开连接延迟属性设置为 30 个属性秒（默认值为 5 秒——`5 * 1000`）。

## 4.4. STOMP

WebSocket 协议定义了两种消息类型（文本消息与二进制消息），但是其内容未定义。
该协议定义了一种机制，供客户端与服务端协商用于在 WebSocket 之上使用的子协议（即高级消息协议），以定义每条消息可以发送的类型、格式是什么、每条消息的内容，等等。
子协议的使用是可选的，但是无论哪种方式，客户端和服务端都需要就定义消息内容的某种协议达成共识。

### 4.4.1. 概览

[STOMP](https://stomp.yueplus.ink/stomp-specification-1.2.html#Abstract)（面向简单文本的消息传递协议）最初是为脚本语言（例如：Ruby、Python 与 Perl）创建的，以连接到企业消息代理。
它旨在解决常用消息传递模式的最小子集。
STOMP 可以在任何可靠的双向流网络协议上使用，例如 TCP 与 WebSocket。
尽管 STOMP 是面向文本的协议，但是消息有效负载可以是文本或二进制。

STOMP 是基于帧的协议，其帧是基于 HTTP 的。
以下清单显示了 STOMP 帧的结构：

```text
COMMAND
header1:value1
header2:value2

Body^@
```

客户端可以使用 `SEND` 或 `SUBSCRIBE` 命令发送或订阅消息，以及描述消息的内容与接收者的 `destination ` 标头。
这启用了一种简单的发布 - 订阅机制，可以使用该机制通过代理将消息发送到其他连接的客户端，或者将消息发送到服务端以请求执行某些工作。

使用 Spring 的 STOMP 支持时，Spring WebSocket 应用程序将充当客户端的 STOMP 代理。
消息被路由到 `@Controller` 消息处理方法或简单的内存中代理，该代理跟踪订阅并向订阅的用户广播消息。
还可以将 Spring 配置为与专用的 STOMP 代理（例如：RabbitMQ、ActiveMQ 与其他代理）一起使用，以实际广播消息。
在那种情况下，Spring 维护与代理的 TCP 连接，将消息中继给它，并将消息从它传递到连接的 WebSocket 客户端。
因此，Spring Web 应用程序可以依靠基于 HTTP 的统一安全性，通用验证以及用于消息处理的熟悉的编程模型。

以下示例展示了一个客户订阅的股票报价，服务端可能会定期发出该股票报价（例如：通过计划的任务，该任务通过 `SimpMessagingTemplate` 将消息发送给代理）：

```text
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@
```

以下示例展示了一个发送交易请求的客户端，服务端可以通过 `@MessageMapping` 方法处理该请求：

```text
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
```

执行后，服务端可以向客户广播交易确认消息与详细信息。

在 STOMP 规范中，目的地的含义是故意不透明的。
它可以是任何字符串，并且完全由 STOMP 服务端定义它们支持的目的地的语义和语法。
但是，目的地通常是类似路径的字符串，其中 `/topic/..` 表示发布 - 订阅（一对多），而 `/queue/` 表示点对点（一对一）消息交流。

STOMP 服务端可以使用 `MESSAGE` 命令向所有订阅者广播消息。
以下示例展示了服务端向订阅的客户端发送股票报价：

```text
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
```

服务端无法发送未经请求的消息。
来自服务端的所有消息都必须响应特定的客户端订阅，并且服务端消息的 `subscription-id` 标头必须与客户端订阅的 `id` 标头匹配。

前面的概述旨在提供对 STOMP 协议的最基本的了解。
建议全面阅读协议 [规范](https://stomp.yueplus.ink/stomp-specification-1.2.html)。

### 4.4.2. 优点

与使用原始 WebSocket 相比，使用 STOMP 作为子协议使 Spring Framework 与 Spring Security 提供了更丰富的编程模型。
关于 HTTP 与原始 TCP 以及它如何让 Spring MVC 与其他 Web 框架提供丰富的功能，可以得出相同的观点。
以下是优点列表：

* 无需发明自定义消息协议与消息格式。

* 可以使用 STOMP 客户端，包括 Spring Framework 中的 [Java 客户端](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-client)。

* 可以（可选）使用消息代理（例如：RabbitMQ、ActiveMQ 与其他代理）来管理订阅与广播消息。

* 可以在任意数量的 `@Controller` 实例中组织应用程序逻辑，并且可以基于 STOMP 目的地标头将消息路由到它们，而不是通过给定连接使用单个 `WebSocketHandler` 处理原始 WebSocket 消息。

* 可以使用 Spring Security 基于 STOMP 目的地与消息类型来保护消息。

### 4.4.3. 启用 STOMP

`spring-messaging` 与 `spring-websocket` 模块中提供了 STOMP 通过 WebSocket 支持。
一旦有了这些依赖关系，就可以使用 [SockJS 回退](#_4-3-sockjs-回退) 通过 WebSocket 公开 STOMP 端点，如以下示例所示：

```Java {10,15,16}
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();  
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.setApplicationDestinationPrefixes("/app"); 
        config.enableSimpleBroker("/topic", "/queue"); 
    }
}
```

1. `/portfolio` 是 WebSocket（或 SockJS）客户端为了 WebSocket 握手需要连接到的端点的 HTTP URL。

2. 其目的地标头以 `/app` 开头的 STOMP 消息被路由到 `@Controller` 类中的 `@MessageMapping` 方法。

3. 使用内置的消息代理进行订阅与广播，以及将目的地标头以 `/topic` 或 `/queue` 开头的消息路由到代理。

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app">
        <websocket:stomp-endpoint path="/portfolio">
            <websocket:sockjs/>
        </websocket:stomp-endpoint>
        <websocket:simple-broker prefix="/topic, /queue"/>
    </websocket:message-broker>

</beans>
```

::: tip
对于内置的简单代理，`/topic` 与 `/queue` 前缀没有任何特殊含义。
它们仅是区分发布订阅消息传递与点对点消息传递的约定（即，许多订阅者与一个消费者）。
使用外部代理时，请检查代理的 STOMP 页面以了解其支持哪种 STOMP 目标与前缀。
:::

要从浏览器连接 SockJS，可以使用 [`sockjs-client`](https://github.com/sockjs/sockjs-client)。
对于 STOMP，许多应用程序都使用了 [jmesnil/stomp-websocket](https://github.com/jmesnil/stomp-websocket) 库（也称为 stomp.js），该库功能齐全，已在生产中使用多年，但不再维护。
目前，[JSteunou/webstomp-client](https://github.com/JSteunou/webstomp-client) 是该库中最活跃且发展最快的后继程序。
以下示例代码基于此：

```JavaScript
var socket = new SockJS("/spring-websocket-portfolio/portfolio");
var stompClient = webstomp.over(socket);

stompClient.connect({}, function(frame) {
}
```

请注意，前面示例中的 `stompClient` 不需要指定 `login` 与 `password` 标头。
即使这样做，它们也会在服务器端被忽略（或更确切地说，被覆盖）。
有关身份验证的更多信息，请参见[连接到代理](#_4-4-10-连接到代理)与[身份验证](#_4-4-12-身份验证)。

有关更多示例代码，请参见：

* [使用 WebSocket 构建交互式 Web 应用程序](https://spring.io/guides/gs/messaging-stomp-websocket/)——入门指南。

* [Stock Portfolio](https://github.com/rstoyanchev/spring-websocket-portfolio)——一个示例应用程序。

### 4.4.4. WebSocket 服务端

要配置基础 WebSocket 服务器，请应用“[服务端配置](#_4-2-4-服务端配置)”中的信息。
但是对于Jetty，需要通过 `StompEndpointRegistry` 设置 `HandshakeHandler` 与 `WebSocketPolicy`：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }
}
```

### 4.4.5. 消息流

公开 STOMP 端点后，Spring 应用程序将成为已连接客户端的 STOMP 代理。
本节描述服务端的消息流。

`spring-messaging` 模块包含对起源于 [Spring Integration](https://spring.io/spring-integration) 的消息传递应用程序的基础支持，后来被提取并合并到 Spring Framework 中，以在许多 Spring 项目与应用程序场景中更广泛地使用。
下面的列表简要描述了一些可用的消息传递抽象：

* [Message](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/Message.html)：
  消息的简单表示，包括标题和有效负载。

* [MessageHandler](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/MessageHandler.html)：
  处理消息的契约。

* [MessageChannel](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/MessageChannel.html)：
  发送消息的契约，这使消息在生产者和消费者之间的松耦合成为可能。

* [SubscribableChannel](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/SubscribableChannel.html)：
  带有 `MessageHandler` 订阅者的 `MessageChannel`。

* [ExecutorSubscribableChannel](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html)：
  使用 `Executor` 传递消息的 `SubscribableChannel`。

Java 配置（即 `@EnableWebSocketMessageBroker`）与 XML 命名空间配置（即 `<websocket：message-broker>`）都使用前面的组件来组装消息工作流。
下图展示了启用简单内置消息代理时使用的组件：

![消息流简单代理](./img/message-flow-simple-broker.png)

上图展示了三个消息通道：

* `clientInboundChannel`：用于传递从 WebSocket 客户端收到的消息。

* `clientOutboundChannel`：用于向 WebSocket 客户端发送服务端消息。

* `brokerChannel`：用于从服务端应用程序代码内将消息发送到消息代理。

下图展示了将外部代理（例如 RabbitMQ）配置为用于管理订阅与广播消息时使用的组件：

![消息流代理转发](./img/message-flow-broker-relay.png)

前面两个图之间的主要区别是使用“代理中继”将消息通过 TCP 传递到外部 STOMP 代理，以及将消息从代理传递到订阅的客户端。

从 WebSocket 连接接收到消息后，它们将被解码为 STOMP 帧，转换为 Spring 消息表示形式，然后发送到 `clientInboundChannel` 进行进一步处理。
例如：目的地标头以 `/app` 开头的 STOMP 消息可以路由到控制器中带 `@MessageMapping` 注解的方法，而 `/topic` 与 `/queue` 消息可以直接路由到消息代理。

处理来自客户端的 STOMP 消息的带注解的 `@Controller` 可以通过 `brokerChannel` 将消息发送到消息代理，并且代理通过 `clientOutboundChannel` 将消息广播给匹配的订阅者。
相同的控制器还可以响应 HTTP 请求执行相同的操作，因此客户端可以执行 HTTP POST，然后 `@PostMapping` 方法可以将消息发送到消息代理，以广播到订阅的客户端。

可以通过一个简单的示例跟踪流程。
考虑以下示例，该示例设置了服务器：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }
}

@Controller
public class GreetingController {

    @MessageMapping("/greeting") {
    public String handle(String greeting) {
        return "[" + getTimestamp() + ": " + greeting;
    }
}
```

前面的示例支持以下流程：

1. 客户端连接到 <http://localhost:8080/portfolio>，一旦建立了 WebSocket 连接，STOMP 帧就开始在其上流动。

2. 客户端发送 SUBSCRIBE 帧，其目的地标头为 `/topic/greeting`。
   接收并解码后，该消息将发送到 `clientInboundChannel`，然后路由到消息代理，该代理存储客户端订阅。
   
3. 客户端向 `/app/greeting` 发送一个 aSEND 帧。
   `/app` 前缀有助于将其路由到带注解的控制器。
   删除 `/app` 前缀后，目标的其余 `/greeting` 部分将映射到 `GreetingController` 中的 `@MessageMapping` 方法。
   
4. 从 `GreetingController` 返回的值被转换为带有有效负载的 Spring 消息，该有效负载基于返回值和 `/topic/greeting` 的默认目的地标头（从输入目的地派生，其中 `/app` 替换为 `/topic`）。
   结果消息将发送到 `brokerChannel` 并由消息代理处理。

5. 消息代理查找所有匹配的订阅者，并通过 `clientOutboundChannel` 向每个消息订阅者发送一个 MESSAGE 帧，消息在该消息中被编码为 STOMP 帧并通过 WebSocket 连接发送。

下一节将提供有关带注解方法的更多详细信息，包括支持的参数类型与返回值。

### 4.4.6. 带注解的控制器

应用程序可以使用带注解的 `@Controller` 类来处理来自客户端的消息。
这样的类可以声明 `@MessageMapping`、`@SubscribeMapping` 与 `@ExceptionHandler` 方法，如以下主题所述：

* [`@MessageMapping`](#messagemapping)
  
* [`@SubscribeMapping`](#subscribemapping)
  
* [`@ExceptionHandler`](#exceptionhandler)

#### `@MessageMapping`

可以使用 `@MessageMapping` 来注解基于目的地路由消息的方法。
在方法级与类型级都支持它。
在类级，`@MessageMapping` 用于表示控制器中所有方法之间的共享映射。

默认情况下，映射值是 Ant 风格的路径模式（例如：`/thing*`、`/thing/**`），包括对模板变量（例如：`/thing/{id}`）的支持。
可以通过 `@DestinationVariable` 方法参数引用这些值。
应用程序还可以切换到以点分隔的映射的目标约定，如“[将点作为分隔符](#_4-4-11-将点作为分隔符)”中所述。

##### 支持的方法参数

下表描述了方法参数：

| 方法参数                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `Message`                                                    | 用于访问完整的消息。                                         |
| `MessageHeaders`                                             | 用于访问 `Message` 中的标头。                                |
| `MessageHeaderAccessor`、`SimpMessageHeaderAccessor`、`StompHeaderAccessor` | 用于通过类型化访问器方法访问标头。                           |
| `@Payload` | 为了访问消息的有效负载，由配置的 `MessageConverter` 转换（例如，从 JSON）。<br />不需要此注解，因为默认情况下会假定没有其它自变量匹配。<br />可以使用 `@javax.validation.Valid` 或 Spring 的 `@Validated` 注解有效负载参数，以自动验证有效负载参数。 |
| `@Header`                                                    | 为了访问特定的标头值——以及必要时使用 `org.springframework.core.convert.converter.Converter` 进行类型转换。 |
| `@Headers`                                                   | 用于访问消息中的所有标头。此参数必须可分配给 `java.util.Map`。 |
| `@DestinationVariable`                                       | 用于访问从消息目的地中提取的模板变量。根据需要将值转换为声明的方法参数类型。 |
| `java.security.Principal`                                    | 反映在 WebSocket HTTP 握手时登录的用户。                     |

##### 返回值

默认情况下，`@MessageMapping` 方法的返回值通过匹配的 `MessageConverter` 序列化为有效负载，并作为消息发送到 `brokerChannel`，并从该消息广播到订阅者。
出站邮件的目的地与入站邮件的目的地相同，但以 `/topic` 为前缀。

可以使用 `@SendTo` 与 `@SendToUser` 注解来自定义输出消息的目的地。
`@SendTo` 用于自定义目标位置或指定多个目标。
`@SendToUser` 用于将输出消息定向到仅与输入消息关联的用户。
请参阅[用户目的地](#_4-4-14-用户目的地)。

可以在同一方法上同时使用 `@SendTo` 与 `@SendToUser`，并且两者在类级都受支持，在这种情况下，它们充当类中方法的默认值。
但是，请记住，任何方法级的 `@SendTo` 或 `@SendToUser` 注解都会在类级别覆盖所有此类批注。

消息可以异步处理，`@MessageMapping` 方法可以返回 `ListenableFuture`、`CompletableFuture` 或 `CompletionStage`。

请注意，`@SendTo` 与 `@SendToUser` 只是一种便利，等同于使用 `SimpMessagingTemplate` 发送消息。
如有必要，对于更高级的方案，可以直接使用 `SimpMessagingTemplate` 来使用 `@MessageMapping` 方法。
这可以代替返回值，也可以附加于返回值。
请参阅[发送消息](#_4-4-7-发送消息)。

#### `@SubscribeMapping`

`@SubscribeMapping` 与 `@MessageMapping` 相似，但是将映射范围缩小到仅订阅消息。
它支持与 `@MessageMapping` 相同的[方法参数](#messagemapping)。
但是，在默认情况下对于返回值，消息直接发送到客户端（通过 `clientOutboundChannel`，作为对订阅的响应），而不发送到代理（通过 `brokerChannel`，作为对匹配订阅的广播）。
添加 `@SendTo` 或 `@SendToUser` 会覆盖此行为，而是发送给代理。

什么时候有用？
假定代理映射到 `/topic` 与 `/queue`，而应用程序控制器映射到 `/app`。
在此设置中，代理将存储 `/topic` 与 `/queue` 的所有订阅，这些订阅旨在进行重复广播，并且不需要应用程序参与。
客户端还可以订阅某个 `/app` 目的地，并且控制器可以响应该订阅而返回一个值，而无需代理，而无需再次存储或使用该订阅（实际上是一次请求 - 答复交换）。
一个用例是在启动时用初始数据填充 UI。

什么时候没用？
不要尝试将代理与控制器映射到相同的目标前缀，除非出于某种原因希望两者都独立处理消息（包括订阅）。
入站消息是并行处理的。
不能保证代理或控制器首先处理给定的消息。
如果要在存储订阅并准备广播时通知目标，那么客户端应询问服务端是否支持收据（简单代理不支持）。
例如，对于 Java [STOMP 客户端](#_4-4-18-stomp-客户端)，可以执行以下操作添加收据：

```Java
@Autowired
private TaskScheduler messageBrokerTaskScheduler;

// During initialization..
stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

// When subscribing..
StompHeaders headers = new StompHeaders();
headers.setDestination("/topic/...");
headers.setReceipt("r1");
FrameHandler handler = ...;
stompSession.subscribe(headers, handler).addReceiptTask(() -> {
    // Subscription ready...
});
```

服务端的一种选择是在 `brokerChannel` 上[注册](#_4-4-17-拦截)一个 `ExecutorChannelInterceptor` 并实现 `afterMessageHandled` 方法，该方法在处理消息（包括订阅）之后被调用。

#### `@ExceptionHandler`

应用程序可以使用 `@MessageExceptionHandler` 方法来处理 `@MessageMapping` 方法中的异常。
如果要访问异常实例，那么可以在注解本身中声明异常，也可以通过方法参数声明异常。
以下示例通过方法参数声明异常：

```Java
@Controller
public class MyController {

    // ...

    @MessageExceptionHandler
    public ApplicationError handleException(MyException exception) {
        // ...
        return appError;
    }
}
```

`@MessageExceptionHandler` 方法支持灵活的方法签名，并支持与 `@MessageMapping` 方法相同的方法参数类型与返回值。

通常，`@MessageExceptionHandler` 方法适用于声明它们的 `@Controller` 类（或类层次结构）。
如果希望此类方法在全局范围内（跨控制器）应用，那么可以在标有 `@ControllerAdvice` 的类中声明它们。
这与 Spring MVC 中可用的[类似支持](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice)相当。

### 4.4.7. 发送消息

如果要从应用程序的任何部分向连接的客户端发送消息怎么办？
任何应用程序组件都可以将消息发送到 `brokerChannel`。
最简单的方法是注入 `SimpMessagingTemplate` 并使用它发送消息。
通常，将按类型注入它，如以下示例所示：

```Java
@Controller
public class GreetingController {

    private SimpMessagingTemplate template;

    @Autowired
    public GreetingController(SimpMessagingTemplate template) {
        this.template = template;
    }

    @RequestMapping(path="/greetings", method=POST)
    public void greet(String greeting) {
        String text = "[" + getTimestamp() + "]:" + greeting;
        this.template.convertAndSend("/topic/greetings", text);
    }

}
```

但是，如果存在另一个相同类型的 bean，也可以通过其名称（`brokerMessagingTemplate`）对其进行限定。

### 4.4.8. 简单代理

内置的简单消息代理处理来自客户端的订阅请求，将其存储在内存中，并将消息广播到具有匹配目的地的已连接客户端。
该代理支持类似路径的目的地，包括订阅 Ant 风格的目的地模式。

::: tip
应用程序还可以使用点分隔（而不是斜杠分隔）目的地。
请参阅[将点作为分隔符](#_4-4-11-将点作为分隔符)。
:::

如果配置了任务调度程序，那么简单代理支持 STOMP 心跳。
为此，可以声明自己的调度程序，也可以使用内部自动声明与使用的调度程序。
以下示例展示如何声明自己的调度程序：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    private TaskScheduler messageBrokerTaskScheduler;

    @Autowired
    public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
        this.messageBrokerTaskScheduler = taskScheduler;
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {

        registry.enableSimpleBroker("/queue/", "/topic/")
                .setHeartbeatValue(new long[] {10000, 20000})
                .setTaskScheduler(this.messageBrokerTaskScheduler);

        // ...
    }
}
```

### 4.4.9. 外部代理

简单代理非常适合入门，但仅支持 STOMP 命令的子集（它不支持 ack、收据与其他一些特性），依赖于简单的消息发送循环，并且不适合于集群。
或者，可以升级应用程序以使用功能齐全的消息代理。

请参阅 STOMP 文档以了解选择的消息代理（例如 [RabbitMQ](https://www.rabbitmq.com/stomp.html)、[ActiveMQ](https://activemq.apache.org/stomp.html) 与其它），安装代理，并在启用 STOMP 支持的情况下运行它。
然后，可以在 Spring 配置中启用 STOMP 代理中继（而不是简单代理）。

以下示例配置启用了功能齐全的代理：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/topic", "/queue");
        registry.setApplicationDestinationPrefixes("/app");
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app">
        <websocket:stomp-endpoint path="/portfolio" />
            <websocket:sockjs/>
        </websocket:stomp-endpoint>
        <websocket:stomp-broker-relay prefix="/topic,/queue" />
    </websocket:message-broker>

</beans>
```

先前配置中的 STOMP 代理中继是一个 Spring [`MessageHandler`](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/messaging/MessageHandler.html)，它通过将消息转发到外部消息代理来处理消息。
为此，它建立到代理的 TCP 连接，将所有消息转发给代理，然后通过客户端的 WebSocket 会话将从代理收到的所有消息转发给客户端。
本质上，它充当双向转发消息的“中继”。

::: tip
将 `io.projectreactor.netty:reactor-netty` 与 `io.netty:netty-all` 所有依赖项添加到项目中以进行 TCP 连接管理。
:::

此外，应用程序组件（例如 HTTP 请求处理方法、业务服务等）还可以将消息发送到代理中继，如“[发送消息](#_4-4-7-发送消息)”中所述，将消息广播到订阅的 WebSocket 客户端。

实际上，代理中继可实现健壮且可伸缩的消息广播。

### 4.4.10. 连接到代理

STOMP 代理中继器维护与代理的单个“系统”TCP 连接。
此连接仅用于源自服务端应用程序的消息，而不用于接收消息。
可以为此连接配置 STOMP 凭据（即 STOMP 帧 `login` 与 `passcode` 标头）。
这在 XML 命名空间与 Java 配置中都以 `systemLogin` 与 `systemPasscode` 属性（默认值为 `guest` 与 `guest`）公开。

::: tip
STOMP 代理中继始终在代表客户端转发给代理的每个 `CONNECT` 帧上设置 `login` 与 `passcode` 标头。
因此，WebSocket 客户端无需设置这些标头。
它们将被忽略。
如“[身份验证](#_4-4-12-身份验证)”部分所述，WebSocket 客户端应改为依靠 HTTP 身份验证来保护 WebSocket 端点并建立客户端身份。
:::

STOMP 代理中继还通过“系统” TCP 连接向消息代理发送与从消息代理接收心跳。
可以配置发送与接收心跳的间隔（默认间隔为 10 秒）。
如果与代理的连接断开，那么代理中继每 5 秒继续尝试重新连接，直到成功。

当与代理的“系统”连接丢失并重新建立时，任何 Spring bean 都可以实现 `ApplicationListener<BrokerAvailabilityEvent>` 来接收通知。
例如，当没有活动的“系统”连接时，广播股票报价的股票报价服务可以停止尝试发送消息。

默认情况下，STOMP 代理中继始终连接到同一主机和端口，如果连接断开，那么根据需要重新连接。
如果希望提供多个地址，那么在每次尝试连接时，都可以配置地址供应商，而不是固定的主机与端口。
以下示例展示了如何执行此操作：

```Java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
        registry.setApplicationDestinationPrefixes("/app");
    }

    private ReactorNettyTcpClient<byte[]> createTcpClient() {
        return new ReactorNettyTcpClient<>(
                client -> client.addressSupplier(() -> ... ),
                new StompReactorNettyCodec());
    }
}
```

还可以使用 `virtualHost` 属性配置 STOMP 代理中继。
此属性的值设置为每个 `CONNECT` 帧的 `host` 标头，这很有用（例如，在云环境中，建立 TCP 连接的实际主机与提供基于云的 STOMP 服务的主机是不同的）。

### 4.4.11. 将点作为分隔符

### 4.4.12. 身份验证

### 4.4.13. 令牌（Token）验证

### 4.4.14. 用户目的地

### 4.4.15. 消息顺序

### 4.4.16. 事件

### 4.4.17. 拦截

### 4.4.18. STOMP 客户端

### 4.4.19. WebSocket 作用域

### 4.4.20. 性能

### 4.4.21. 监控

### 4.4.22. 测试
