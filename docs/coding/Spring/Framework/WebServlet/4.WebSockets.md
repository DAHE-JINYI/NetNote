# 4. WebSockets

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket)

此部分参考文档涵盖对 Servlet 堆栈的支持，包括原始 WebSocket 交互的 WebSocket 消息传递，通过 SockJS 进行 WebSocket 仿真以及通过 STOMP 作为 WebSocket 的子协议进行发布、订阅消息传递。

## 4.1. WebSocket 概论

WebSocket 协议 [RFC 6455](https://tools.ietf.org/html/rfc6455) 提供了一种标准化方法，可通过单个 TCP 连接在客户端与服务端之间建立全双工双向通信通道。
它是与 HTTP 不同的 TCP 协议，但旨在通过端口 80 与 443 在 HTTP 上工作，并允许重复使用现有的防火墙规则。

WebSocket 交互始于一个 HTTP 请求，该请求使用 HTTP `Upgrade` 标头进行升级，或者在这种情况下切换到 WebSocket 协议。
以下示例显示了这种交互：

```YAML {3,4}
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080
```

1. `Upgrade` 标头。
2. 使用 `Upgrade` 连接。

具有 WebSocket 支持的服务端代替通常的 200 状态代码，返回类似于以下内容的输出：

```YAML {1}
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```

1. 协议切换

握手成功后，HTTP 升级请求的基础 TCP 套接字将保持打开状态，客户端与服务端均可继续发送与接收消息。

WebSockets 的工作原理的完整介绍超出了本文档的范围。
请参阅 RFC 6455，HTML5 的 WebSocket 章节，或 Web 上的许多简介和教程中的任何一个。

请注意，如果 WebSocket 服务端在 Web 服务器（例如 nginx）后面运行，那么可能需要对其进行配置，以将 WebSocket 升级请求传递到 WebSocket 服务器。
同样，如果应用程序在云环境中运行，请检查与 WebSocket 支持相关的云提供商的说明。

### 4.1.1. HTTP 对比 WebSocket

尽管 WebSocket 被设计为与 HTTP 兼容并以 HTTP 请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构与应用程序编程模型。

在 HTTP 与 REST 中，应用程序被建模为许多 URL。
为了与应用程序交互，客户端访问那些 URL，即请求 - 响应样式。
服务端根据 HTTP URL、方法与标头将请求路由到适当的处理程序。

相比之下，在 WebSockets 中，初始连接通常只有一个 URL。
随后，所有应用程序消息都在同一 TCP 连接上流动。
这指向了一个完全不同的异步、事件驱动的消息传递体系结构。

WebSocket 也是一种低级传输协议，与 HTTP 不同，它不对消息的内容规定任何语义。
这意味着除非客户端与服务端就消息语义达成一致，否则就无法路由或处理消息。

WebSocket 客户端与服务端可以通过 HTTP 握手请求上的 `Sec-WebSocket-Protocol` 标头协商使用更高级别的消息协议（例如 STOMP）。
在这种情况下，它们需要提出自己的约定。

### 4.1.2. 何时使用 WebSockets

WebSockets 可以使网页具有动态性与交互性。
但是，在许多情况下，结合使用 Ajax 与 HTTP 流或长时间轮询可以提供一种简单有效的解决方案。

例如，新闻、邮件与社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。
另一方面，协作、游戏与金融应用程序需要更接近实时。

仅延迟并不是决定因素。
如果消息量相对较少（例如，监视网络故障），那么 HTTP 流或轮询可以提供有效的解决方案。
低延迟，高频率与高音量的结合才是使用 WebSocket 的最佳案例。

还请记住，在 Internet 上，不受控制的代理可能会阻止 WebSocket 交互，这可能是因为未将它们配置为传递 `Upgrade` 标头，或者是因为它们关闭了长期处于空闲状态的连接。
这意味着与面向公众的应用程序相比，将 WebSocket 用于防火墙内部的应用程序是一个更直接的决定。

## 4.2. WebSocket API

### 4.2.1. `WebSocketHandler`

### 4.2.2. WebSocket 握手

### 4.2.3. 部署

### 4.2.4. 服务端配置

### 4.2.5. 允许的来源

## 4.3. SockJS 回退

### 4.3.1. 概览

### 4.3.2. 启用 SockJS

### 4.3.3. IE8 与 IE9

### 4.3.4. 心跳

### 4.3.5. 客户端挂断

### 4.3.6. SockJS 与 CORS

### 4.3.7. `SockJsClient`

## 4.4. STOMP

### 4.4.1. 概览

### 4.4.2. 优点

### 4.4.3. 启用 STOMP

### 4.4.4. WebSocket 服务端

### 4.4.5. 消息流

### 4.4.6. 带注释的控制器

### 4.4.7. 发送消息

### 4.4.8. 简单代理

### 4.4.9. 外部代理

### 4.4.10. 连接到代理

### 4.4.11. 将点作为分隔符

### 4.4.12. 身份验证

### 4.4.13. 令牌（Token）验证

### 4.4.14. 用户目的地

### 4.4.15. 消息顺序

### 4.4.16. 事件

### 4.4.17. 拦截

### 4.4.18. STOMP 客户端

### 4.4.19. WebSocket 作用域

### 4.4.20. 性能

### 4.4.21. 监控

### 4.4.22. 测试
