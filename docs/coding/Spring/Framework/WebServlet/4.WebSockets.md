# 4. WebSockets

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket)

此部分参考文档涵盖对 Servlet 堆栈的支持，包括原始 WebSocket 交互的 WebSocket 消息传递，通过 SockJS 进行 WebSocket 仿真以及通过 STOMP 作为 WebSocket 的子协议进行发布、订阅消息传递。

## 4.1. WebSocket 概论

WebSocket 协议 [RFC 6455](https://tools.ietf.org/html/rfc6455) 提供了一种标准化方法，可通过单个 TCP 连接在客户端与服务端之间建立全双工双向通信通道。
它是与 HTTP 不同的 TCP 协议，但旨在通过端口 80 与 443 在 HTTP 上工作，并允许重复使用现有的防火墙规则。

WebSocket 交互始于一个 HTTP 请求，该请求使用 HTTP `Upgrade` 标头进行升级，或者在这种情况下切换到 WebSocket 协议。
以下示例展示了这种交互：

```YAML {3,4}
GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket 
Connection: Upgrade 
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080
```

1. `Upgrade` 标头。
2. 使用 `Upgrade` 连接。

具有 WebSocket 支持的服务端代替通常的 200 状态代码，返回类似于以下内容的输出：

```YAML {1}
HTTP/1.1 101 Switching Protocols 
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp
```

1. 协议切换

握手成功后，HTTP 升级请求的基础 TCP 套接字将保持打开状态，客户端与服务端均可继续发送与接收消息。

WebSockets 的工作原理的完整介绍超出了本文档的范围。
请参阅 RFC 6455，HTML5 的 WebSocket 章节，或 Web 上的许多简介和教程中的任何一个。

请注意，如果 WebSocket 服务端在 Web 服务器（例如 nginx）后面运行，那么可能需要对其进行配置，以将 WebSocket 升级请求传递到 WebSocket 服务器。
同样，如果应用程序在云环境中运行，请检查与 WebSocket 支持相关的云提供商的说明。

### 4.1.1. HTTP 对比 WebSocket

尽管 WebSocket 被设计为与 HTTP 兼容并以 HTTP 请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构与应用程序编程模型。

在 HTTP 与 REST 中，应用程序被建模为许多 URL。
为了与应用程序交互，客户端访问那些 URL，即请求 - 响应样式。
服务端根据 HTTP URL、方法与标头将请求路由到适当的处理程序。

相比之下，在 WebSockets 中，初始连接通常只有一个 URL。
随后，所有应用程序消息都在同一 TCP 连接上流动。
这指向了一个完全不同的异步、事件驱动的消息传递体系结构。

WebSocket 也是一种低级传输协议，与 HTTP 不同，它不对消息的内容规定任何语义。
这意味着除非客户端与服务端就消息语义达成一致，否则就无法路由或处理消息。

WebSocket 客户端与服务端可以通过 HTTP 握手请求上的 `Sec-WebSocket-Protocol` 标头协商使用更高级别的消息协议（例如 STOMP）。
在这种情况下，它们需要提出自己的约定。

### 4.1.2. 何时使用 WebSockets

WebSockets 可以使网页具有动态性与交互性。
但是，在许多情况下，结合使用 Ajax 与 HTTP 流或长时间轮询可以提供一种简单有效的解决方案。

例如，新闻、邮件与社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。
另一方面，协作、游戏与金融应用程序需要更接近实时。

仅延迟并不是决定因素。
如果消息量相对较少（例如，监视网络故障），那么 HTTP 流或轮询可以提供有效的解决方案。
低延迟，高频率与高音量的结合才是使用 WebSocket 的最佳案例。

还请记住，在 Internet 上，不受控制的代理可能会阻止 WebSocket 交互，这可能是因为未将它们配置为传递 `Upgrade` 标头，或者是因为它们关闭了长期处于空闲状态的连接。
这意味着与面向公众的应用程序相比，将 WebSocket 用于防火墙内部的应用程序是一个更直接的决定。

## 4.2. WebSocket API

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handler)

Spring 框架提供了一个 WebSocket API，可用于编写处理 WebSocket 消息的客户端与服务端应用程序。

### 4.2.1. `WebSocketHandler`

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handler)

创建 WebSocket 服务端就像实现 `WebSocketHandler` 一样简单，或者更可能地，扩展 `TextWebSocketHandler` 或 `BinaryWebSocketHandler`。
下面的示例使用 `TextWebSocketHandler`：

```JAVA
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.TextMessage;

public class MyHandler extends TextWebSocketHandler {

    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) {
        // ...
    }

}
```

有专用的 WebSocket Java 配置与 XML 命名空间支持，用于将前面的 WebSocket 处理程序映射到特定的 URL，如以下示例所示：

```JAVA
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

前面的示例用于 Spring MVC 应用程序，应该包含在 [`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) 的配置中。
但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。
在 [`WebSocketHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html) 的帮助下将 `WebSocketHandler` 集成到其他 HTTP 服务环境中相对简单。

### 4.2.2. WebSocket 握手

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-handshake)

定制初始 HTTP WebSocket 握手请求的最简单方法是通过 `HandshakeInterceptor`，它公开了“握手之前”与“握手之后”的方法。
可以使用此类拦截器来阻止握手或使任何属性对 `WebSocketSession` 可用。
以下示例使用内置的拦截器将 HTTP 会话属性传递到 WebSocket 会话：

```JAVA
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyHandler(), "/myHandler")
            .addInterceptors(new HttpSessionHandshakeInterceptor());
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:handshake-interceptors>
            <bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
        </websocket:handshake-interceptors>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

一个更高级的选项是扩展 `DefaultHandshakeHandler`，它执行 WebSocket 握手的步骤，包括验证客户端来源、协商子协议以及其他详细信息。
如果应用程序需要配置自定义 `RequestUpgradeStrategy` 以便适应尚不支持的 WebSocket 服务器引擎与版本，那么可能还需要使用此选项
（有关此主题的更多信息，请参阅 [部署](#_4-2-3-部署)）。
Java 配置与 XML 命名空间都使配置自定义 `HandshakeHandler` 成为可能。

::: warning
Spring 提供了一个 `WebSocketHandlerDecorator` 基类，可用于装饰 `WebSocketHandler` 并具有其他行为。
使用 WebSocket Java 配置或 XML 命名空间时，默认情况下会提供并添加日志记录与异常处理实现。
`ExceptionWebSocketHandlerDecorator` 捕获由任何 `WebSocketHandler` 方法引起的所有未捕获的异常，并关闭状态为 `1011`（指示服务器错误）的 WebSocket 会话。
:::

### 4.2.3. 部署

Spring WebSocket API 易于集成到 Spring MVC 应用程序中，在该应用程序中，`DispatcherServlet` 同时提供 HTTP WebSocket 握手与其他 HTTP 请求。
通过调用 `WebSocketHttpRequestHandler`，也很容易集成到其他 HTTP 处理方案中。
这是方便且易于理解的。
但是，对于 JSR-356 运行时，需要特别注意。

Java WebSocket API（JSR-356）提供了两种部署机制。
首先涉及启动时的 Servlet 容器类路径扫描（Servlet 3 特性）。
另一个是在 Servlet 容器初始化时使用的注册 API。
这两种机制均无法使用单个“前端控制器”进行所有 HTTP 处理（包括 WebSocket 握手与所有其他 HTTP 请求，例如：Spring MVC 的 `DispatcherServlet`）。

这是 JSR-356 的一个重大限制，即使在 JSR-356 运行时中运行，Spring 的 WebSocket 支持也可以通过服务器特定的 `RequestUpgradeStrategy` 实现解决。
Tomcat、Jetty、GlassFish、WebLogic、WebSphere 与 Undertow（与 WildFly）目前存在此类策略。

::: tip
已经创建了克服 Java WebSocket API 中的上述限制的请求，可以在 [eclipse-ee4j/websocket-api#211](https://github.com/eclipse-ee4j/websocket-api/issues/211) 中进行跟踪。
Tomcat、Undertow 与 WebSphere 提供了自己的 API 替代方案，使之可以做到这一点，而 Jetty 也可以实现。
我们希望更多的服务端可以做到这一点。
:::

第二个考虑因素是，希望支持 JSR-356 的 Servlet 容器执行 `ServletContainerInitializer`（SCI）扫描，这可能会减慢应用程序的启动速度，在某些情况下会大大降低速度。
如果在升级到具有 JSR-356 支持的 Servlet 容器版本后观察到重大影响，那么应该可以通过使用 `web.xml` 中的 `<absolute-ordering />` 元素有选择地启用或禁用 Web 片段（和 SCI 扫描）,如以下示例所示：

```XML
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering/>

</web-app>
```

然后，可以按名称选择性地启用 Web 片段，例如 Spring 自己的 `SpringServletContainerInitializer`，它提供对 Servlet 3 Java 初始化 API 的支持。
以下示例展示了如何执行此操作：

```XML
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">

    <absolute-ordering>
        <name>spring_web</name>
    </absolute-ordering>

</web-app>
```

### 4.2.4. 服务端配置

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-config)

每个基础的 WebSocket 引擎都公开配置属性，这些属性控制运行时特征，例如消息缓冲区大小的大小、空闲超时等。

对于 Tomcat、WildFly 与 GlassFish，可以将 `ServletServerContainerFactoryBean` 添加到 WebSocket Java 配置中，如以下示例所示：

```JAVA
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        container.setMaxTextMessageBufferSize(8192);
        container.setMaxBinaryMessageBufferSize(8192);
        return container;
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <bean class="org.springframework...ServletServerContainerFactoryBean">
        <property name="maxTextMessageBufferSize" value="8192"/>
        <property name="maxBinaryMessageBufferSize" value="8192"/>
    </bean>

</beans>
```

::: tip
对于客户端 WebSocket 配置，应使用 `WebSocketContainerFactoryBean`（XML）或 `ContainerProvider.getWebSocketContainer()`（Java 配置）。
:::

对于 Jetty，需要提供一个预先配置的 Jetty `WebSocketServerFactory`，然后通过 WebSocket Java 配置将其注入 Spring 的 `DefaultHandshakeHandler` 中。
以下示例展示了如何执行此操作：

```JAVA
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoWebSocketHandler(),
            "/echo").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/echo" handler="echoHandler"/>
        <websocket:handshake-handler ref="handshakeHandler"/>
    </websocket:handlers>

    <bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
        <constructor-arg ref="upgradeStrategy"/>
    </bean>

    <bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
        <constructor-arg ref="serverFactory"/>
    </bean>

    <bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
        <constructor-arg>
            <bean class="org.eclipse.jetty...WebSocketPolicy">
                <constructor-arg value="SERVER"/>
                <property name="inputBufferSize" value="8092"/>
                <property name="idleTimeout" value="600000"/>
            </bean>
        </constructor-arg>
    </bean>

</beans>
```

### 4.2.5. 允许的来源

[WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-websocket-server-cors)

从 Spring Framework 4.1.5 开始，WebSocket 与 SockJS 的默认行为是仅接受同源请求。
也可以允许所有或指定的来源列表。
此检查主要用于浏览器客户端。
没有任何措施可以阻止其他类型的客户端修改 `Origin` 标头值（有关更多详细信息，请参阅 [RFC 6454: Web 源概念](https://tools.ietf.org/html/rfc6454)）。

三种可能的行为是：

* 仅允许相同来源的请求（默认）：
  在此模式下，启用 SockJS 后，Iframe HTTP 响应标头 `X-Frame-Options` 设置为 `SAMEORIGIN`，并且 JSONP 传输被禁用，因为它不允许检查请求的来源。
  因此，启用此模式时，不支持 IE6 与 IE7。

* 允许指定来源列表：
  每个允许的来源必须以 `http://` 或 `https://` 开头。
  在此模式下，启用 SockJS 后，将禁用 IFrame 传输。
  因此，启用此模式时，不支持 IE6 到 IE9。

* 允许所有来源：
  要启用此模式，应提供 `*` 作为允许的来源值。
  在这种模式下，所有传输都可用。

可以配置 WebSocket 与 SockJS 允许的来源，如以下示例所示：

```JAVA
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers allowed-origins="https://mydomain.com">
        <websocket:mapping path="/myHandler" handler="myHandler" />
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

## 4.3. SockJS 回退

在公共互联网上，控件外部的限制性代理可能会阻止 WebSocket 交互，这可能是因为未将它们配置为传递 `Upgrade` 标头，或者是因为它们关闭了长期处于空闲状态的连接。

解决此问题的方法是 WebSocket 模拟，即先尝试使用 WebSocket，然后再尝试使用基于 HTTP 的技术来模拟 WebSocket 交互并公开相同的应用程序级 API。

在 Servlet 技术栈上，Spring 框架为 SockJS 协议提供服务端与客户端支持。

### 4.3.1. 概览

SockJS 的目标是让应用程序使用 WebSocket API，但在运行时的必要时刻回退到非 WebSocket 替代方案，而无需更改应用程序代码。

SockJS 包含：

* [SockJS 协议](https://github.com/sockjs/sockjs-protocol)以可执行 [叙述性测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html) 的形式定义。

* [SockJS JavaScript 客户端](https://github.com/sockjs/sockjs-client/)——一种在浏览器中使用的客户端库。

* SockJS 服务端实现，包含一个 Spring 框架的 `spring-websocket` 模块。

* `spring-websocket` 模块中的 SockJS Java 客户端（从 4.1 版开始）。

SockJS 设计用于浏览器。
它使用多种技术来支持各种浏览器版本。
有关 SockJS 传输类型与浏览器的完整列表，请参见 [SockJS 客户端](https://github.com/sockjs/sockjs-client/)页面。
传输分为三大类：WebSocket、HTTP 流与 HTTP 长轮询。
有关这些类别的概述，请参阅[此博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

SockJS 客户端首先发送 `GET/info` 以从服务端获取基本信息。
在那之后，它必须决定使用哪种传输方式。
如果可能，将使用 WebSocket。
如果没有，在大多数浏览器中，至少有一个 HTTP 流选项。
如果不是，则使用 HTTP（长）轮询。

所有传输请求都具有以下 URL 结构：

```text
https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
```

此处：

* `{server-id}` 用于在集群中路由请求，但在其他情况下不使用。

* `{session-id}` 用于关联属于 SockJS 会话的 HTTP 请求。

* `{transport}` 用于指示传输类型（例如：websocket、xhr-streaming、等）。

WebSocket 传输仅需要单个 HTTP 请求即可进行 WebSocket 握手。
此后所有消息在该套接字上交换。

HTTP 传输需要更多请求。
例如，Ajax/XHR 流依赖于对服务器到客户端消息的一个长时间运行的请求，以及对客户端到服务端消息的其他 HTTP POST 请求。
长轮询与此类似，不同之处在于长轮询在每次服务端到客户端发送后结束当前请求。

SockJS 增加了最小消息帧。
例如，服务器最初发送字母 `o`（“开启”帧），消息以 `a["message1","message2"]`（JSON 编码数组）发送，如果 25 秒内（默认）没有消息，那么发送字母 `h`（“心跳”帧），最后使用字母 `c`（“关闭”帧）关闭会话。

要了解更多信息，请在浏览器中运行示例并查看 HTTP 请求。
SockJS 客户端允许修复传输列表，因此可以一次查看每个传输。
SockJS 客户端还提供了调试标志，该标志可在浏览器控制台中支持有用的消息。
在服务器端，可以为 `org.springframework.web.socket` 启用 `TRACE` 日志记录。
有关更多详细信息，请参见 SockJS 协议[叙述测试](https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html)。

### 4.3.2. 使能 SockJS

可以通过 Java 配置启用 SockJS，如以下示例所示：

```JAVA
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").withSockJS();
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}
```

下面的示例展示与前面的示例等效的 XML 配置：

```XML
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:handlers>
        <websocket:mapping path="/myHandler" handler="myHandler"/>
        <websocket:sockjs/>
    </websocket:handlers>

    <bean id="myHandler" class="org.springframework.samples.MyHandler"/>

</beans>
```

前面的示例用于 Spring MVC 应用程序，应该包含在 [`DispatcherServlet`](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) 的配置中。
但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。
在 [`WebSocketHttpRequestHandler`](https://docs.spring.io/spring-framework/docs/5.3.4/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html) 的帮助下将 `WebSocketHandler` 集成到其他 HTTP 服务环境中相对简单。

在浏览器端，应用程序可以使用 [`sockjs-client`](https://github.com/sockjs/sockjs-client/)（版本 1.0.x）。
它模拟 W3C WebSocket API，并与服务器通信以选择最佳的传输选项，具体取决于运行它的浏览器。
请参阅 [sockjs-client](https://github.com/sockjs/sockjs-client/) 页面与浏览器支持的传输类型列表。
客户端还提供了几个配置选项，例如用于指定要包含的传输。

### 4.3.3. IE 8 与 9

Internet Explorer 8 与 9 仍在使用。
它们是拥有 SockJS 的关键原因。
本节涵盖有关在这些浏览器中运行的重要注意事项。

SockJS 客户端通过使用 Microsoft 的 [`XDomainRequest`](https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx) 在 IE 8 与 9 中支持 Ajax/XHR 流。
跨域有效，但不支持发送 Cookie。
Cookies 对于 Java 应用程序通常是必不可少的。
但是，由于 SockJS 客户端可用于多种服务端类型（而不仅仅是 Java 类型），因此它需要知道 cookie 是否重要。
如果是这样，那么 SockJS 客户端更倾向 Ajax/XHR 进行流传输。
否则，它依赖于基于 iframe 的技术。

SockJS 客户端的第一个 `/info` 请求是对详细信息的请求，这些信息可以影响客户端对传输方式的选择。
这些详细信息之一是服务器应用程序是否依赖 Cookie（例如，出于身份验证目的或使用粘性会话进行群集）。
Spring 对 SockJS 的支持包括一个名为 `sessionCookieNeeded` 的属性。
由于大多数 Java 应用程序都依赖 `JSESSIONID` cookie，因此默认情况下启用该功能。
如果应用程序不需要它，那么可以关闭此选项，然后 SockJS 客户端应在 IE 8 与 9 中选择 `xdr-streaming`。

如果确实使用基于 iframe 的传输，请记住，可以通过将 HTTP 响应标头 `X-Frame-Options` 设置为 `DENY`、`SAMEORIGIN` 或 `ALLOW-FROM <origin>` 来指示浏览器阻止在给定页面上使用 iframe。
这用于防止[点击劫持](https://www.owasp.org/index.php/Clickjacking)。

::: tip
Spring Security 3.2+ 提供了对每个响应设置 `X-Frame-Options` 的支持。
默认情况下，Spring Security Java 配置将其设置为 `DENY`。
在 3.2 中，Spring Security XML 命名空间默认情况下不设置该标头，但可以配置为这样做。
将来，它可能会成为默认设置。

有关如何配置 `X-Frame-Options` 标头设置的详细信息，请参见 Spring Security 文档的[默认安全标头](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers)。
也可以查看 [SEC-2501](https://jira.spring.io/browse/SEC-2501) 以获取更多背景信息。
:::

如果应用程序添加了 `X-Frame-Options` 响应标头（应该如此！）并依赖于基于 iframe 的传输，那么需要将标头值设置为 `SAMEORIGIN` 或 `ALLOW-FROM <origin>`。
Spring SockJS 支持还需要知道 SockJS 客户端的位置，因为它是从 iframe 加载的。
默认情况下，iframe 设置为从 CDN 位置下载 SockJS 客户端。
最好将此选项配置为使用与应用程序源相同的 URL。

以下示例展示了如何在 Java 配置中执行此操作：

```JAVA
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS()
                .setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
    }

    // ...

}
```

XML 命名空间通过 `<websocket:sockjs>` 元素提供了类似的选项。

::: tip
在初始开发过程中，请启用 SockJS 客户端开发模式，以防止浏览器缓存本应缓存的 SockJS 请求（如 iframe）。
有关如何启用它的详细信息，请参见 [SockJS 客户端](https://github.com/sockjs/sockjs-client/) 页面。
:::

### 4.3.4. 心跳

SockJS 协议要求服务端发送心跳消息，以防止代理断定连接挂起。
Spring SockJS 配置具有一个名为 `heartbeatTime` 的属性，可用于自定义频率。
默认情况下，假设没有其他消息在该连接上发送，那么心跳将在 25 秒后发送。
这个 25 秒的值符合以下对公共互联网应用程序的 [IETF 建议](https://tools.ietf.org/html/rfc6202)。

::: tip
在 WebSocket 与 SockJS 上使用 STOMP 时，如果 STOMP 客户端与服务端协商要交换的心跳，将会禁用 SockJS 心跳。
:::

Spring SockJS 支持还允许配置 `TaskScheduler` 来计划心跳任务。
任务调度程序由线程池支持，其默认设置基于可用处理器的数量。
应该考虑根据特定需求自定义设置。

### 4.3.5. 客户端挂断

HTTP 流与 HTTP 长轮询 SockJS 传输要求连接保持打开的时间比平常更长。
有关这些技术的概述，请参见[此博客文章](https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/)。

在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，该支持允许退出 Servlet 容器线程，处理请求并继续写入另一个线程的响应。

一个特定的问题是，Servlet API 不会为已离开的客户端提供通知。
请参阅 [eclipse-ee4j/servlet-api#44](https://github.com/eclipse-ee4j/servlet-api/issues/44)。
但是，Servlet 容器在随后尝试写入响应时会引发异常。
由于 Spring 的 SockJS 服务支持服务器发送的心跳信号（默认情况下，每 25 秒发送一次），这意味着通常会在该时间段内（如果消息发送频率更高将更早）检测到客户端断开连接。

::: tip
结果，由于客户端已断开连接，可能会发生网络 I/O 故障，这可能会在日志中填充不必要的堆栈跟踪。
Spring 会尽最大努力找出代表客户端断开连接（特定于每个服务器）的网络故障，并通过使用专用日志类别 `DISCONNECTED_CLIENT_LOG_CATEGORY`（在 `AbstractSockJsSession` 中定义）来记录一条最小的消息。
如果需要查看堆栈跟踪，可以将该日志类别设置为 `TRACE`。
:::

### 4.3.6. SockJS 与 CORS

如果允许跨域请求（请参阅“[允许的来源](#_4-2-5-允许的来源)”），那么 SockJS 协议使用 CORS 在 XHR 流与轮询传输中提供跨域支持。
因此，除非在响应中检测到 CORS 标头的存在，否则将自动添加 CORS 标头。
因此，如果已经将应用程序配置为提供 CORS 支持（例如，通过 Servlet 过滤器），那么 Spring 的 `SockJsService` 会跳过这一部分。

也可以通过在 Spring 的 SockJsService 中设置 `suppressCors` 属性来禁止添加这些 CORS 标头。

SockJS 需要以下标头与值：

* `Access-Control-Allow-Origin`：从 `Origin` 请求标头的值初始化。

* `Access-Control-Allow-Credentials`：始终设置为 `true`。

* `Access-Control-Request-Headers`：从等效请求标头中的值初始化。

* `Access-Control-Allow-Methods`：传输支持的 HTTP 方法（请参见 `TransportType` 枚举）。

* `Access-Control-Max-Age`：设置为 31536000（1 年）。

有关确切的实现，请参见 `AbstractSockJsService` 中的 `addCorsHeaders` 与源代码中的 `TransportType` 枚举。

另外，如果 CORS 配置允许，请考虑排除带有 SockJS 端点前缀的 URL，从而让 Spring 的 `SockJsService` 处理它。

### 4.3.7. `SockJsClient`

Spring 提供了一个 SockJS Java 客户端，无需使用浏览器即可连接到远程 SockJS 端点。
当需要通过公共网络在两个服务器之间进行双向通信时（这是网络代理可以阻止使用 WebSocket 协议的地方），这特别有用。
SockJS Java 客户端对于测试目的（例如，模拟大量并发用户）也非常有用。

SockJS Java 客户端支持 `websocket`、`xhr-streaming` 与 `xhr-polling` 传输。
其余的仅在浏览器中有意义。

可以使用以下命令配置 `WebSocketTransport`：

* JSR-356 运行时的 `StandardWebSocketClient`

* 通过使用 Jetty 9+ 本机 WebSocket API 来创建 `JettyWebSocketClient`。

* Spring 的 `WebSocketClient` 的任何实现。

根据定义，`XhrTransport` 支持 `xhr-streaming` 与 `xhr-polling`，因为从客户端的角度来看，除了用于连接服务器的 URL 之外没有其他区别。
当前有两种实现：

* `RestTemplateXhrTransport` 使用 Spring 的 `RestTemplate` 进行 HTTP 请求。

* `JettyXhrTransport` 使用 Jetty 的 `HttpClient` 进行 HTTP 请求。

以下示例展示了如何创建 SockJS 客户端并连接到 SockJS 端点：

```JAVA
List<Transport> transports = new ArrayList<>(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

SockJsClient sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
```

::: tip
SockJS 对消息使用 JSON 格式的数组。
默认情况下，使用 Jackson 2，并且需要在类路径上。
或者，可以配置 `SockJsMessageCodec` 的自定义实现，并在 `SockJsClient` 上对其进行配置。
:::

要使用 `SockJsClient` 模拟大量并发用户，需要配置基础 HTTP 客户端（用于 XHR 传输）以允许足够数量的连接与线程。
以下示例展示了如何使用 Jetty 进行操作：

```JAVA
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
```

下面的示例展示了与服务器端 SockJS 相关的属性（有关详细信息，请参见 javadoc），还应该考虑自定义：

```JAVA {7,8,9}
@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/sockjs").withSockJS()
            .setStreamBytesLimit(512 * 1024) 
            .setHttpMessageCacheSize(1000) 
            .setDisconnectDelay(30 * 1000); 
    }

    // ...
}
```

1. 将 `streamBytesLimit` 属性设置为 512KB（默认值为 128KB——`128 * 1024`）。

2. 将 `httpMessageCacheSize` 属性设置为 1,000（默认值为 `100`）。

3. 将断开连接延迟属性设置为 30 个属性秒（默认值为 5 秒——`5 * 1000`）。

## 4.4. STOMP

### 4.4.1. 概览

### 4.4.2. 优点

### 4.4.3. 启用 STOMP

### 4.4.4. WebSocket 服务端

### 4.4.5. 消息流

### 4.4.6. 带注释的控制器

### 4.4.7. 发送消息

### 4.4.8. 简单代理

### 4.4.9. 外部代理

### 4.4.10. 连接到代理

### 4.4.11. 将点作为分隔符

### 4.4.12. 身份验证

### 4.4.13. 令牌（Token）验证

### 4.4.14. 用户目的地

### 4.4.15. 消息顺序

### 4.4.16. 事件

### 4.4.17. 拦截

### 4.4.18. STOMP 客户端

### 4.4.19. WebSocket 作用域

### 4.4.20. 性能

### 4.4.21. 监控

### 4.4.22. 测试
